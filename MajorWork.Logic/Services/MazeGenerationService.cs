using System.Linq;
using MajorWork.Logic.Models;
using MajorWork.Logic.Helpers;

namespace MajorWork.Logic.Services
{
    /// <summary>
    /// This service takes the coordinates for a maze, and then returns a completely random perfect maze generated by depth first search
    /// It's difficulty is then increased by DifficultyIncrease()
    /// 
    /// For a more thorough description check the documentation for full psuedocode
    /// </summary>


    public class MazeGenerationService
    {
        private readonly Maze _mazeGrid;

        public MazeGenerationService(int userLength, int userWidth, Maze mazeGridUser)
        {
            _mazeGrid = mazeGridUser;

            _mazeGrid.Width = userWidth;
            _mazeGrid.Length = userLength;

            _mazeGrid.MazeStack.Add(new Stack
            {
                X = 0,
                Y = 0
            });

            GenerateEmptyGrid();
            DepthFirstSearch(0, 0);
            _mazeGrid.MazeGrid.First(a => (a.X == (0) && a.Y == 0)).IsPath = true; //Ensure the start position is a pathway and not a wall.
            DifficultyIncrease();
        }

        private void GenerateEmptyGrid()
        {
            for (int j = 0; j < _mazeGrid.Width; j++)
            {
                for (int k = 0; k < _mazeGrid.Length; k++)
                {
                    _mazeGrid.MazeGrid.Add(new Mazepoints(j, k, false, false));
                }
            }
        }

        private void DepthFirstSearch(int x, int y)
        {
            while (_mazeGrid.MazeStack.Count != 0)
            {
                bool statement = false;
                //Generate a random selection of integers
                int[] randDirections = RandomDirections();

                //Choose a direction to explore
                for (int i = 0; i < 5; i++)
                {
                    switch (randDirections[i])
                    {
                        case 0: //Additonal case statments increase the bias in horizontal path generation creating long sweeping corridors with dead ends
                        case 5:
                        case 7:
                            if (x - 2 <= 0) //Left
                                continue;

                            if (_mazeGrid.MazeGrid.First(a => (a.X == (x - 2) && a.Y == y)).IsPath == false)
                            {
                                _mazeGrid.MazeGrid.First(a => (a.X == (x - 2) && a.Y == y)).IsPath = true;
                                _mazeGrid.MazeGrid.First(a => (a.X == (x - 1) && a.Y == y)).IsPath = true;

                                x = x - 2;
                                AddValueToStack(x, y);
                                i = 5;
                                statement = true;
                            }
                            break;

                        case 1:


                            if (y + 2 > _mazeGrid.Length - 1) //Up
                                continue;

                            if (_mazeGrid.MazeGrid.First(a => (a.X == x && a.Y == (y + 2))).IsPath == false)
                            {
                                _mazeGrid.MazeGrid.First(a => (a.X == (x) && a.Y == (y + 2))).IsPath = true;
                                _mazeGrid.MazeGrid.First(a => (a.X == (x) && a.Y == (y + 1))).IsPath = true;

                                y = y + 2;
                                AddValueToStack(x, y);
                                i = 5;
                                statement = true;
                            }
                            break;

                        case 2:
                        case 6:
                        case 8:
                            if (x + 2 >= _mazeGrid.Length - 1) //Right
                                continue;

                            if (_mazeGrid.MazeGrid.First(a => (a.X == (x + 2) && a.Y == y)).IsPath == false)
                            {
                                _mazeGrid.MazeGrid.First(a => (a.X == (x + 2) && a.Y == (y))).IsPath = true;
                                _mazeGrid.MazeGrid.First(a => (a.X == (x + 1) && a.Y == (y))).IsPath = true;


                                x = x + 2;
                                AddValueToStack(x, y);
                                i = 5;
                                statement = true;
                            }
                            break;

                        case 3:

                            if (y - 2 <= 0) //Down
                                continue;

                            if (_mazeGrid.MazeGrid.First(a => (a.X == x && a.Y == (y - 2))).IsPath == false)
                            {
                                _mazeGrid.MazeGrid.First(a => (a.X == (x) && a.Y == (y - 1))).IsPath = true;
                                _mazeGrid.MazeGrid.First(a => (a.X == (x) && a.Y == (y - 2))).IsPath = true;

                                y = y - 2;
                                AddValueToStack(x, y);
                                i = 5;
                                statement = true;
                            }
                            break;

                    }
                }
                if (statement == false) //If there are no possible pathways pop the next node off the stack and continue
                {
                    var stackLength = _mazeGrid.MazeStack.Count - 1;

                    x = _mazeGrid.MazeStack[stackLength].X;
                    y = _mazeGrid.MazeStack[stackLength].Y;
                    _mazeGrid.MazeStack.RemoveAt(stackLength);
                }

            }

        }

        private void DifficultyIncrease() //Removes parts of the walls creating more possible pathways with some leading to deadends
        {
            foreach (var child in _mazeGrid.MazeGrid)
            {
                var decisionToRemove = MathRandom.GetRandomNumber(0, 20);
                if (decisionToRemove == 5)
                {
                    child.IsPath = true;
                }

            }
        }

        private void AddValueToStack(int x, int y)
        {
            _mazeGrid.MazeStack.Add(new Stack
            {
                X = x,
                Y = y
            });
        }

        private static int[] RandomDirections() //Generates an array of directions that is used to decide the order in the Depth First Search switch statemnet
        {
            int[] randoms = new int[8];

            for (int i = 0; i < randoms.Length; i++)
            {
                randoms[i] = i;
            }

            for (int i = randoms.Length; i > 1; i--)
            {
                int a = MathRandom.GetRandomNumber(0, i);
                int tmp = randoms[a];
                randoms[a] = randoms[i - 1];
                randoms[i - 1] = tmp;
            }
            return randoms;
        }
    }
}
