using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Collections;

using MajorWork.Logic.Models;
using MajorWork.Logic.Helpers;
using System.Diagnostics;

namespace MajorWork.Logic.Services
{
    /* This service takes the coordinates for a maze, and then returns a completely random maze
    generated by depth first search */

    public class MazeGenerationService
    {
        private maze mazeGrid;

        public MazeGenerationService(int userLength, int userWidth, ref maze mazeGridUser)
        {
            mazeGrid = mazeGridUser;
            
            mazeGrid.width = userWidth;
            mazeGrid.length = userLength;

            mazeGrid.mazeStack.Add(new stack
            {
                X = 0,
                Y = 0
            });

            GenerateEmptyGrid();
            GenerateMaze(0,0);
            mazeGrid.mazeGrid.Where(a => (a.X == (0) && a.Y == 0)).First().isWall = true;
        }

        private void GenerateEmptyGrid()
        {         
            for (int j = 0; j < mazeGrid.width; j++)
            {
                for (int k = 0; k < mazeGrid.length; k++)
                {
                    mazeGrid.mazeGrid.Add(new mazepoints(j, k, false));
                }
            }
        }

        private void GenerateMaze(int x, int y)
        {
            while (mazeGrid.mazeStack.Count != 0)
            {
                int[] randDirections = RandomDirections();
                for (int i = 0; i < randDirections.Length; i++)
                {
                    switch (randDirections[i])
                    {
                        case 0:
                            if (x-2 <= 0)
                                continue;

                            if (mazeGrid.mazeGrid.Where(a => (a.X == (x-2) && a.Y == y)).First().isWall == false)
                            {
                                mazeGrid.mazeGrid.Where(a => (a.X == (x - 2) && a.Y == y)).First().isWall = true;
                                mazeGrid.mazeGrid.Where(a => (a.X == (x - 1) && a.Y == y)).First().isWall = true;

                                addValueToStack(x, y);

                                x = x - 2;

                                GenerateMaze(x, y);
                            }
                            break;

                        case 1:
                            if(y + 2 > mazeGrid.length -1)
                                continue;

                            if (mazeGrid.mazeGrid.Where(a => (a.X == x && a.Y == (y+2))).First().isWall == false)
                            { 
                                mazeGrid.mazeGrid.Where(a => (a.X == (x) && a.Y == (y + 2))).First().isWall = true;
                                mazeGrid.mazeGrid.Where(a => (a.X == (x) && a.Y == (y + 1))).First().isWall = true;

                                addValueToStack(x, y);

                                y = y + 2;

                                GenerateMaze(x, y);
                            }
                            break;

                        case 2:
                            if (x + 2 >= mazeGrid.length - 1)
                                continue;

                            if (mazeGrid.mazeGrid.Where(a => (a.X == (x+2) && a.Y == y)).First().isWall == false)
                            {
                                mazeGrid.mazeGrid.Where(a => (a.X == (x + 2) && a.Y == (y))).First().isWall = true;
                                mazeGrid.mazeGrid.Where(a => (a.X == (x + 1) && a.Y == (y))).First().isWall = true;

                                addValueToStack(x, y);

                                x = x + 2;

                                GenerateMaze(x, y);
                            }
                            break;

                        case 3:
                            if (y - 2 <= 0)
                                continue;

                            if (mazeGrid.mazeGrid.Where(a => (a.X == x && a.Y == (y-2))).First().isWall == false)
                            {
                                mazeGrid.mazeGrid.Where(a => (a.X == (x) && a.Y == (y - 1))).First().isWall = true;
                                mazeGrid.mazeGrid.Where(a => (a.X == (x) && a.Y == (y - 2))).First().isWall = true;

                                addValueToStack(x, y);

                                y = y - 2;

                                GenerateMaze(x, y);
                            }
                            break;
                    }
                }

                if (mazeGrid.mazeStack.Count != 0)
                {
                    //Pop the most recent node from the stack

                    var stackLength = mazeGrid.mazeStack.Count() - 1;

                    x = mazeGrid.mazeStack[stackLength].X;
                    y = mazeGrid.mazeStack[stackLength].Y;
                    mazeGrid.mazeStack.RemoveAt(stackLength);

                    GenerateMaze(x, y);
                }
            }
        }

        public void addValueToStack(int x, int y)
        {
            mazeGrid.mazeStack.Add(new stack
            {
                X = x,
                Y = y
            });
        }

        public int[] RandomDirections()
        {
            int[] randoms = new int[4];

            for (int i = 0; i < randoms.Length; i++)
            {
                randoms[i] = i;
            }       

            for (int i = randoms.Length; i > 1; i--)
            {
                int a = MathRandom.GetRandomNumber(0, i);
                int tmp = randoms[a];
                randoms[a] = randoms[i - 1];
                randoms[i - 1] = tmp;
            }
            return randoms;
        }
    }
}
